<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>‡∏ß‡∏á‡∏•‡πâ‡∏≠‡∏™‡∏∏‡πà‡∏°‡∏ä‡∏∑‡πà‡∏≠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
  <div id="center"
     style="
       min-height:100vh;
       display:flex;
       flex-direction:column;
       align-items:center;
       justify-content:center;
       margin-top: 30px;
     ">


 <div id="center">

<h2>üé° ‡∏ß‡∏á‡∏•‡πâ‡∏≠‡∏™‡∏∏‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠</h2>

<textarea id="nameInput" rows="6" cols="20">
Ned
Robret
Jaime
Catalyn
</textarea><br>



<canvas id="wheel" width="300" height="300"></canvas>
 </div>
 </body>
<script>
/* ================== ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏•‡πá‡∏≠‡∏Å ================== */
const LOCK_INDEX = 1;
/* ================================================= */

const canvas = document.getElementById("wheel");
const ctx = canvas.getContext("2d");
const cx = canvas.width / 2;
const cy = canvas.height / 2;
const outerR = canvas.width / 2;
const innerR = 55;

const nameInput = document.getElementById("nameInput");

let names = [];
let angle = 0;
let spinning = false;

/* ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏∑‡πà‡∏≠ */
function loadNames() {
  names = nameInput.value
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);
}

/* ‡∏ß‡∏≤‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!names.length) return;

  drawWheel();
  /* ‡∏ß‡∏≤‡∏î‡∏Ç‡∏≠‡∏ö‡∏ß‡∏á‡∏•‡πâ‡∏≠‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏° */
  drawWheelBorder()
function drawWheelBorder() {
  // ‡πÄ‡∏á‡∏≤‡∏ü‡∏∏‡πâ‡∏á‡∏£‡∏≠‡∏ö‡∏ß‡∏á
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, outerR - 2, 0, Math.PI * 2);
  ctx.shadowColor = "rgba(0,0,0,0.25)";
  ctx.shadowBlur = 20;
  ctx.strokeStyle = "white";
  ctx.lineWidth = 10;
  ctx.stroke();
  ctx.restore();

  // ‡∏Ç‡∏≠‡∏ö‡∏ß‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å (‡∏Ç‡∏≤‡∏ß‡∏Ñ‡∏°)
  ctx.beginPath();
  ctx.arc(cx, cy, outerR - 2, 0, Math.PI * 2);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 6;
  ctx.stroke();

  // ‡∏Ç‡∏≠‡∏ö‡∏ß‡∏á‡∏î‡πâ‡∏≤‡∏ô‡πÉ‡∏ô (‡∏£‡∏≠‡∏ö‡∏£‡∏π START)
  ctx.beginPath();
  ctx.arc(cx, cy, innerR + 2, 0, Math.PI * 2);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.stroke();
}

  drawArrow();
  drawCenterButton();
}

/* ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏•‡πâ‡∏≠ */
function drawWheel() {
  const slice = Math.PI * 2 / names.length;

  for (let i = 0; i < names.length; i++) {
    const start = angle + i * slice;
    const end = start + slice;

    ctx.beginPath();
    ctx.arc(cx, cy, outerR - 5, start, end);
    ctx.arc(cx, cy, innerR, end, start, true);
    ctx.closePath();
    ctx.fillStyle = `hsl(${i * 360 / names.length},70%,70%)`;
    ctx.fill();

    // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(start + slice / 2);
    ctx.textAlign = "right";
    ctx.font = "bold 20px Arial";
    ctx.fillStyle = "#000";
    ctx.fillText(names[i], outerR - 20, 6);
    ctx.restore();
  }
}

/* ‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô (‡∏Ñ‡∏ß‡πà‡∏≥‡∏•‡∏á + ‡∏¢‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏ä‡∏∑‡πà‡∏≠) */
function drawArrow() {
  const offsetY = -18; // üëà ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ (‡∏¢‡∏¥‡πà‡∏á‡∏ï‡∏¥‡∏î‡∏•‡∏ö ‡∏¢‡∏¥‡πà‡∏á‡∏™‡∏π‡∏á)

  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 3;

  ctx.beginPath();
  ctx.moveTo(cx, 42 + offsetY);        // ‡∏õ‡∏•‡∏≤‡∏¢‡πÅ‡∏´‡∏•‡∏°‡∏•‡πà‡∏≤‡∏á
  ctx.lineTo(cx - 22, 6 + offsetY);    // ‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô
  ctx.lineTo(cx + 22, 6 + offsetY);    // ‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô
  ctx.closePath();

  ctx.fill();
  ctx.stroke();
}


/* ‡∏õ‡∏∏‡πà‡∏° START */
function drawCenterButton() {
  ctx.beginPath();
  ctx.arc(cx, cy, innerR - 5, 0, Math.PI * 2);
  ctx.fillStyle = "#fff";
  ctx.fill();
  ctx.shadowColor = "rgba(0,0,0,0.2)";
  ctx.shadowBlur = 10;

  ctx.fillStyle = "#5aa9e6";
  ctx.font = "bold 22px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("START", cx, cy);
  ctx.shadowBlur = 0;
}

/* ‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏•‡∏¥‡∏Å START */
canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - cx;
  const y = e.clientY - rect.top - cy;
  if (Math.sqrt(x*x + y*y) <= innerR) spin();
});

/* ‡∏´‡∏°‡∏∏‡∏ô (logic ‡πÄ‡∏î‡∏¥‡∏°) */
function spin() {
  if (spinning) return;
  loadNames();
  if (!names.length) return alert("‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô");

  const slice = Math.PI * 2 / names.length;
  const spins = Math.floor(Math.random() * 40) + 40;

  const target =
    Math.PI * 2 * spins
    - Math.PI / 2
    - LOCK_INDEX * slice
    - slice / 2;

  const start = angle;
  const startTime = performance.now();
  const duration = 9000;
  spinning = true;

  function animate(t) {
    const p = Math.min((t - startTime) / duration, 1);
    const ease = 1 - Math.pow(1 - p, 3);
    angle = start + (target - start) * ease;
    draw();

    if (p < 1) requestAnimationFrame(animate);
    else {
      spinning = false;
      alert("üéØ ‡πÑ‡∏î‡πâ‡∏ä‡∏∑‡πà‡∏≠: " + names[LOCK_INDEX]);
    }
  }
  requestAnimationFrame(animate);
}

/* init */
loadNames();
draw();
nameInput.addEventListener("input", () => {
  if (spinning) return;   // ‚ùå ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≠‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏°‡∏∏‡∏ô
  loadNames();
  draw();                 // ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏•‡πâ‡∏≠‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
});

</script>


</body>
</html>

